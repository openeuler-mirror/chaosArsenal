/*
Copyright 2023 Sangfor Technologies Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"errors"
	"net/url"
	golangswaggerpaths "path"

	"github.com/go-openapi/strfmt"
)

// GetFaultsURL generates an URL for the get faults operation
type GetFaultsURL struct {
	Domain     *string
	FaultType  *string
	ID         *string
	InjectTime *strfmt.DateTime
	Status     *string
	UpdateTime *strfmt.DateTime

	_basePath string
	// avoid unkeyed usage
	_ struct{}
}

// WithBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *GetFaultsURL) WithBasePath(bp string) *GetFaultsURL {
	o.SetBasePath(bp)
	return o
}

// SetBasePath sets the base path for this url builder, only required when it's different from the
// base path specified in the swagger spec.
// When the value of the base path is an empty string
func (o *GetFaultsURL) SetBasePath(bp string) {
	o._basePath = bp
}

// Build a url path and query string
func (o *GetFaultsURL) Build() (*url.URL, error) {
	var _result url.URL

	var _path = "/faults"

	_basePath := o._basePath
	if _basePath == "" {
		_basePath = "/arsenal/v1"
	}
	_result.Path = golangswaggerpaths.Join(_basePath, _path)

	qs := make(url.Values)

	var domainQ string
	if o.Domain != nil {
		domainQ = *o.Domain
	}
	if domainQ != "" {
		qs.Set("domain", domainQ)
	}

	var faultTypeQ string
	if o.FaultType != nil {
		faultTypeQ = *o.FaultType
	}
	if faultTypeQ != "" {
		qs.Set("fault-type", faultTypeQ)
	}

	var idQ string
	if o.ID != nil {
		idQ = *o.ID
	}
	if idQ != "" {
		qs.Set("id", idQ)
	}

	var injectTimeQ string
	if o.InjectTime != nil {
		injectTimeQ = o.InjectTime.String()
	}
	if injectTimeQ != "" {
		qs.Set("inject-time", injectTimeQ)
	}

	var statusQ string
	if o.Status != nil {
		statusQ = *o.Status
	}
	if statusQ != "" {
		qs.Set("status", statusQ)
	}

	var updateTimeQ string
	if o.UpdateTime != nil {
		updateTimeQ = o.UpdateTime.String()
	}
	if updateTimeQ != "" {
		qs.Set("update-time", updateTimeQ)
	}

	_result.RawQuery = qs.Encode()

	return &_result, nil
}

// Must is a helper function to panic when the url builder returns an error
func (o *GetFaultsURL) Must(u *url.URL, err error) *url.URL {
	if err != nil {
		panic(err)
	}
	if u == nil {
		panic("url can't be nil")
	}
	return u
}

// String returns the string representation of the path with query string
func (o *GetFaultsURL) String() string {
	return o.Must(o.Build()).String()
}

// BuildFull builds a full url with scheme, host, path and query string
func (o *GetFaultsURL) BuildFull(scheme, host string) (*url.URL, error) {
	if scheme == "" {
		return nil, errors.New("scheme is required for a full url on GetFaultsURL")
	}
	if host == "" {
		return nil, errors.New("host is required for a full url on GetFaultsURL")
	}

	base, err := o.Build()
	if err != nil {
		return nil, err
	}

	base.Scheme = scheme
	base.Host = host
	return base, nil
}

// StringFull returns the string representation of a complete url
func (o *GetFaultsURL) StringFull(scheme, host string) string {
	return o.Must(o.BuildFull(scheme, host)).String()
}
